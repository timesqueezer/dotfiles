#!/usr/bin/env bash

set -euo pipefail

DEBUG="${DEBUG:-0}"

if [[ "$DEBUG" != 0 ]]; then
    export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
    set -x
fi

NS="vpnns"
WG_IFACE="wg0"
WG_CONF="/etc/wireguard/${WG_IFACE}.conf"

BRIDGE="br1"
BRIDGE_ADDR="10.10.10.1/24"

VETH_NS="veth1"
VETH_ROOT="br-veth1"
VETH_NS_ADDR="10.10.10.2/24"

DEFAULT_DNS="1.1.1.1"

CHECK="${CHECK:-1}"
CHECK_FATAL="${CHECK_FATAL:-0}"
CHECK_HOST="${CHECK_HOST:-www.google.com}"

log() {
    printf '[%s] %s\n' "$(date +'%F %T')" "$*" >&2
}

warn() {
    log "WARN: $*"
}

die() {
    log "ERROR: $*"
    exit 1
}

need_cmd() {
    command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

need_file() {
    [[ -f "$1" ]] || die "Missing required file: $1"
}

netns_exists() {
    ip netns list | awk '{print $1}' | grep -qx "$NS"
}

link_exists_root() {
    ip link show dev "$1" >/dev/null 2>&1
}

link_exists_ns() {
    ip -n "$NS" link show dev "$1" >/dev/null 2>&1
}

wg_conf_interface_values() {
    local key="$1"
    awk -v want_key="$key" '
        function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
        function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
        function trim(s)  { return rtrim(ltrim(s)) }

        BEGIN {
            in_iface = 0
            want = tolower(want_key)
        }
        /^[ \t]*\[Interface\][ \t]*$/ { in_iface = 1; next }
        /^[ \t]*\[/ { if (in_iface) exit }
        in_iface {
            line = $0
            sub(/[;#].*$/, "", line)
            if (line ~ /^[ \t]*$/) next

            n = split(line, parts, "=")
            if (n < 2) next

            k = trim(parts[1])
            v = substr(line, index(line, "=") + 1)
            v = trim(v)

            if (tolower(k) == want && v != "") print v
        }
    ' "$WG_CONF"
}

wg_setconf_from_wg_quick_conf() {
    # `wg setconf` cannot parse wg-quick-only keys (Address, DNS, PostUp, ...).
    # Build a temporary config containing only keys understood by `wg`.
    local out="$1"
    awk '
        function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
        function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
        function trim(s)  { return rtrim(ltrim(s)) }
        function lower(s) { return tolower(s) }

        BEGIN { section = "" }

        /^[ \t]*\[Interface\][ \t]*$/ { section = "interface"; print "[Interface]"; next }
        /^[ \t]*\[Peer\][ \t]*$/      { section = "peer";      print "[Peer]";      next }
        /^[ \t]*\[/                   { section = "other"; next }

        {
            line = $0
            sub(/[;#].*$/, "", line)
            line = trim(line)
            if (line == "") next
            # Only keep key=value lines
            n = split(line, parts, "=")
            if (n < 2) next
            key = trim(parts[1])
            val = trim(substr(line, index(line, "=") + 1))
            if (val == "") next
            k = lower(key)

            if (section == "interface") {
                # Allowed keys for `wg setconf` in [Interface]
                if (k == "privatekey" || k == "listenport" || k == "fwmark") {
                    print key " = " val
                }
                next
            }

            if (section == "peer") {
                # Allowed keys for `wg setconf` in [Peer]
                if (k == "publickey" || k == "presharedkey" || k == "allowedips" || k == "endpoint" || k == "persistentkeepalive") {
                    print key " = " val
                }
                next
            }
        }
    ' "$WG_CONF" >"$out"
}

debug_dump_state() {
    log "--- DEBUG STATE DUMP START ---"
    set +e
    log "ip netns list:"; ip netns list >&2
    log "ip -d link show:"; ip -d link show >&2

    if netns_exists; then
        log "ip -n $NS -d link show:"; ip -n "$NS" -d link show >&2
        log "ip -n $NS addr show:"; ip -n "$NS" addr show >&2
        log "ip -n $NS -4 route show:"; ip -n "$NS" -4 route show >&2
        log "ip -n $NS -6 route show:"; ip -n "$NS" -6 route show >&2
        if command -v wg >/dev/null 2>&1; then
            log "wg show (in netns):"; ip netns exec "$NS" wg show >&2
        fi
    fi

    set -e
    log "--- DEBUG STATE DUMP END ---"
}

write_netns_resolv_conf() {
    local resolv_dir="/etc/netns/$NS"
    local resolv_tmp
    resolv_tmp="$(mktemp)"

    local dns_raw
    dns_raw="$(wg_conf_interface_values DNS | tr ',' '\n' | sed -e 's/[[:space:]]//g' -e '/^$/d' | tr '\n' ' ')"
    if [[ -z "$dns_raw" ]]; then
        dns_raw="$DEFAULT_DNS"
    fi

    : >"$resolv_tmp"
    for dns in $dns_raw; do
        printf 'nameserver %s\n' "$dns" >>"$resolv_tmp"
    done

    mkdir -p "$resolv_dir"
    chmod 0755 "$resolv_dir"
    mv "$resolv_tmp" "$resolv_dir/resolv.conf"
    chmod 0644 "$resolv_dir/resolv.conf"

    if [[ "$DEBUG" != 0 ]]; then
        log "wrote $resolv_dir/resolv.conf:"; cat "$resolv_dir/resolv.conf" >&2
    fi
}

connectivity_check() {
    if (( CHECK == 0 )); then
        return 0
    fi

    if ! command -v fping >/dev/null 2>&1; then
        warn "fping not found; skipping connectivity check"
        return 0
    fi

    if ip netns exec "$NS" fping -q -c1 -t3000 "$CHECK_HOST"; then
        log "Connectivity check OK: $CHECK_HOST"
        return 0
    fi

    warn "Connectivity check FAILED: $CHECK_HOST"

    if [[ "$DEBUG" != 0 ]]; then
        set +e
        log "Check diagnostics:"
        log "resolv.conf:"; cat "/etc/netns/$NS/resolv.conf" >&2
        log "route (v4):"; ip -n "$NS" -4 route show >&2
        log "route (v6):"; ip -n "$NS" -6 route show >&2
        log "try ping 1.1.1.1:"; ip netns exec "$NS" ping -c1 -w3 1.1.1.1 >&2
        log "try ping 8.8.8.8:"; ip netns exec "$NS" ping -c1 -w3 8.8.8.8 >&2
        log "try resolve host:"; ip netns exec "$NS" getent ahosts "$CHECK_HOST" >&2
        set -e
    fi

    if (( CHECK_FATAL != 0 )); then
        return 1
    fi

    return 0
}

usage() {
    cat >&2 <<EOF
Usage: $0 up|down|run <cmd...>

Commands:
  up      Create/reuse netns + WireGuard interface and bring them up
  down    Tear everything down (best-effort)
  run     Run a command inside the namespace (e.g. $0 run curl https://ifconfig.me)
EOF
}

cleanup_best_effort() {
    set +e
    rm -rf "/etc/netns/$NS" 2>/dev/null
    ip link del "$VETH_ROOT" 2>/dev/null
    ip link del "$BRIDGE" 2>/dev/null
    ip netns delete "$NS" 2>/dev/null
    ip link del "$WG_IFACE" 2>/dev/null
    set -e
}

iface_up() {
    need_cmd ip
    need_cmd wg
    need_file "$WG_CONF"

    if [[ ${UID:-$(id -u)} != 0 ]]; then
        die "This must be run as root."
    fi

    local created_netns=0
    local created_bridge=0
    local created_veth=0

    cleanup_on_error() {
        local exit_code=$?
        local failed_cmd="${BASH_COMMAND:-unknown}"
        local failed_line="${BASH_LINENO[0]:-unknown}"
        warn "up failed (exit $exit_code) at line $failed_line: $failed_cmd"
        if [[ "$DEBUG" != 0 ]]; then
            debug_dump_state
        fi
        set +e

        rm -rf "/etc/netns/$NS" 2>/dev/null

        if (( created_veth == 1 )); then
            ip link del "$VETH_ROOT" 2>/dev/null
        fi

        if (( created_bridge == 1 )); then
            ip link del "$BRIDGE" 2>/dev/null
        fi

        if (( created_netns == 1 )); then
            ip netns delete "$NS" 2>/dev/null
        fi

        set -e
        exit "$exit_code"
    }
    trap cleanup_on_error ERR

    if netns_exists; then
        log "Reusing existing netns: $NS"
    else
        log "Creating netns: $NS"
        ip netns add "$NS"
        created_netns=1
    fi

    if link_exists_ns "$WG_IFACE"; then
        log "Reusing existing $WG_IFACE in netns"
    elif link_exists_root "$WG_IFACE"; then
        log "Moving existing $WG_IFACE into netns"
        ip link set "$WG_IFACE" netns "$NS"
    else
        log "Creating $WG_IFACE"
        ip link add "$WG_IFACE" type wireguard
        ip link set "$WG_IFACE" netns "$NS"
    fi

    local addr_raw
    addr_raw="$(wg_conf_interface_values Address | tr ',' '\n' | sed -e 's/[[:space:]]//g' -e '/^$/d')"
    if [[ -z "$addr_raw" ]]; then
        warn "No Address= found in $WG_CONF; leaving wg interface unaddressed"
    else
        if [[ "$DEBUG" != 0 ]]; then
            log "Addresses from $WG_CONF:"; printf '%s\n' "$addr_raw" >&2
        fi
        while IFS= read -r addr; do
            [[ -z "$addr" ]] && continue
            ip -n "$NS" address replace "$addr" dev "$WG_IFACE"
        done <<<"$addr_raw"
    fi

    local wg_conf_tmp
    wg_conf_tmp="$(mktemp)"
    wg_setconf_from_wg_quick_conf "$wg_conf_tmp"
    if [[ "$DEBUG" != 0 ]]; then
        log "wg setconf input (filtered):"; cat "$wg_conf_tmp" >&2
    fi
    ip netns exec "$NS" wg setconf "$WG_IFACE" "$wg_conf_tmp"
    rm -f "$wg_conf_tmp"
    ip -n "$NS" link set "$WG_IFACE" up
    ip -n "$NS" -4 route replace default dev "$WG_IFACE"
    ip -n "$NS" -6 route replace default dev "$WG_IFACE"

    if link_exists_root "$BRIDGE"; then
        log "Reusing existing bridge: $BRIDGE"
    else
        log "Creating bridge: $BRIDGE"
        ip link add name "$BRIDGE" type bridge
        created_bridge=1
    fi
    ip link set "$BRIDGE" up
    ip addr replace "$BRIDGE_ADDR" dev "$BRIDGE"

    if link_exists_root "$VETH_ROOT"; then
        log "Reusing existing veth root: $VETH_ROOT"
    else
        log "Creating veth pair: $VETH_NS <-> $VETH_ROOT"
        ip link add "$VETH_NS" type veth peer name "$VETH_ROOT"
        created_veth=1
        ip link set "$VETH_NS" netns "$NS"
    fi

    if ! link_exists_ns "$VETH_NS"; then
        if link_exists_root "$VETH_NS"; then
            log "Moving existing $VETH_NS into netns"
            ip link set "$VETH_NS" netns "$NS"
        else
            die "Expected $VETH_NS in netns but not found; try '$0 down' to reset"
        fi
    fi

    ip link set "$VETH_ROOT" up
    ip link set "$VETH_ROOT" master "$BRIDGE"

    ip -n "$NS" link set "$VETH_NS" up
    ip -n "$NS" addr replace "$VETH_NS_ADDR" dev "$VETH_NS"

    if [[ "$DEBUG" != 0 ]]; then
        local dns_raw
        dns_raw="$(wg_conf_interface_values DNS | tr ',' '\n' | sed -e 's/[[:space:]]//g' -e '/^$/d')"
        if [[ -n "$dns_raw" ]]; then
            log "DNS from $WG_CONF:"; printf '%s\n' "$dns_raw" >&2
        else
            log "DNS not set in $WG_CONF (will use default $DEFAULT_DNS)"
        fi
    fi

    write_netns_resolv_conf
    connectivity_check

    trap - ERR
    log "Namespace $NS is up"
}

iface_down() {
    if [[ ${UID:-$(id -u)} != 0 ]]; then
        die "This must be run as root."
    fi

    set +e

    if netns_exists; then
        ip netns pids "$NS" 2>/dev/null | xargs -r kill 2>/dev/null
    fi

    rm -rf "/etc/netns/$NS" 2>/dev/null
    ip link del "$VETH_ROOT" 2>/dev/null
    ip link del "$BRIDGE" 2>/dev/null
    ip netns delete "$NS" 2>/dev/null
    ip link del "$WG_IFACE" 2>/dev/null

    set -e
    log "Namespace $NS is down"
}

run() {
    if [[ ${UID:-$(id -u)} != 0 ]]; then
        die "This must be run as root."
    fi

    shift
    if ! netns_exists; then
        die "Namespace $NS does not exist; run '$0 up' first"
    fi
    exec ip netns exec "$NS" "$@"
}

case "${1:-}" in
    up)
        iface_up
        ;;
    down)
        iface_down
        ;;
    run)
        if [[ $# -lt 2 ]]; then
            usage
            exit 1
        fi
        run "$@"
        ;;
    -h|--help|help|"")
        usage
        exit 0
        ;;
    *)
        usage
        exit 1
        ;;
esac
